
/* 
 Author : Islam Akef Ebeid
 Affiliations : University of Arkansas at Little Rock - Emerging Analytics Center
 */
/* 
 * 
 * xlpm.js is written by Islam Akef Ebeid in effort to display the data supplied in the file generated by the XLPM project representing peptide interactions
 * 
 */

//Global Variables
unit = 25;
scaleValue = 1;
fileWeight = 0;
treemapX = 0;
treemapY = 0;
treemapWidth = 0;
treemapHight = 0;
colorLegendHeight = 0;
thirdLevelWidth = 0;
thirdLevelHeight = 0;
thirdLevelX = 0;
thirdLevelY = 0;
visGroup = 0;
calculatedHeight = 0;
calculatedWidth = 0;
layoutObj = null;
sequences_table_taffy = [];
character_table_taffy = [];
peptide_1_selected = [];
peptide_2_selected = [];
svgDrawnFlag = 0;

function init(svgDim) {
    var width = svgDim.w;
    var height = svgDim.h;
    $("#vis").width(width).height(height);


    layoutObj = new Layout("vis");
    layoutObj.constructViewPortMatrix();
    var svg = layoutObj.getSvg();
    svg.style("font-family", "Helvetica").style("font-size", "8px");
    var infoGroup = svg.append("g").attr("id", "infoGroup");
    layoutObj.putObjectAt(2, 2, infoGroup);
    var legendGroup = infoGroup.append("g").attr("id", "legendGroup");
    var scaleGroup = infoGroup.append("g").attr("id", "scaleGroup");
    visGroup = svg.append("g").attr("id", "visGroup");
    layoutObj.putObjectAt(2, 10, visGroup);
    var firstGroup = visGroup.append("g").attr("id", "first");
    var secondGroup = visGroup.append("g").attr("id", "second");
    var thirdGroup = visGroup.append("g").attr("id", "third");
    return {width: width, height: height};
}

//Utitily functions
function clearSecondLevelData() {
    d3.select("#third").remove();
    d3.select("#second").remove();
}
function clearSVG() {
    window.location.reload(true);
}
function minimize(group, x, y, value) {
    var s = Snap(group);
    var g = s;
    var myMatrix = new Snap.Matrix();
    myMatrix.scale(value, value);
    myMatrix.translate(x, y);
    myMatrix.invert();
    g.animate({transform: myMatrix}, 2000, mina.bounce, function () {
        g.animate({transform: myMatrix}, 2000, mina.bounce);
    });
}
function maximize(group, x, y, value) {
    var s = Snap(group);
    var g = s;
    var myMatrix = new Snap.Matrix();
    myMatrix.scale(value, value);
    myMatrix.translate(x, y);
    myMatrix.invert();
    g.animate({transform: myMatrix}, 2000, mina.bounce, function () {
        g.animate({transform: myMatrix}, 2000, mina.bounce);
    });
}

//Create main SVG element
function calculateLWSVG(fastaFile) {
    var countValid = 0;
    var firstSeq = "";
    var secondSeq = "";
    var lines = fastaFile.split('\n');
    for (var j = 0; j < lines.length; j++) {
        var line = lines[j];
        line = line.trim();
        if (line.length !== 0) {
            if (line[0] === '>') {
                countValid++;
                continue;
            }
            if (countValid === 1) {
                firstSeq += line;
            }
            if (countValid > 1) {
                secondSeq += line;
            }
        }
    }
    calculatedHeight = secondSeq.length * 8;
    calculatedWidth = document.getElementById("vis").clientWidth - 25;
    unit = (calculatedWidth / calculatedHeight) * 1.68 + 20;
    fileWeight = firstSeq.length * secondSeq.length;
    return {w: calculatedWidth, h: calculatedHeight};
}

function drawSVG(gridGroup, width, height) {
    var widthRatio = width / (4.15 * unit);
    var heightRatio = height / (3.9 * unit);
    var data = [];
    for (var k = 0; k < heightRatio; k++) {
        data.push(d3.range(widthRatio));
    }
    var grp = gridGroup.selectAll("g")
            .data(data)
            .enter()
            .append("g")
            .attr("transform", function (d, i) {
                return "translate(0, " + (4 * unit) * i + ")";
            });
    grp.selectAll("rect")
            .data(function (d) {
                return d;
            })
            .enter()
            .append("rect")
            .attr("x", function (d, i) {
                return (4 * unit) * i;
            })
            .attr("width", (4 * unit))
            .attr("height", (4 * unit))
            .style("fill", "#fff")
            .style("stroke", "#ccc")
            .style("stroke-width", "1");
}



//Parse data from the 2 input files (fasta , spectra data)
function checkForSpecialCharacters(sequence) {
    var specialChars = ["!", "@", "#", "$", "%", "^"];
    var specialCharactersObjectsArray = [{char: "!", rep: "C"}, {char: "@", rep: "C"}, {char: "#", rep: "C"}, {char: "$", rep: "M"}, {char: "%", rep: "N"}, {char: "^", rep: "Q"}];
    var input = sequence.toString();
    var specialCharactersObjectsArrayTaffy = TAFFY(specialCharactersObjectsArray);
    var indecies = [];
    function setCharAt(str, index, chr) {
        var returnStr;
        for (var i = 0; i < str.length; i++) {
            var firsPart = str.substring(0, index);
            var secondPart = str.substring(index + 1, str.length);
            returnStr = firsPart + chr + secondPart;
        }
        return returnStr;
    }
    for (var i = 0; i < input.length; i++) {
        if (specialChars.indexOf(input[i]) !== -1) {
            indecies.push(i);
        }
    }
    var pears = input;
    for (var i = 0; i < indecies.length; i++) {
        var obj = specialCharactersObjectsArrayTaffy({char: input.charAt(indecies[i])}).get();
        pears = setCharAt(pears, indecies[i], obj[0].rep);
    }
    return pears;
}

function createSequenceTable(fastaFile) {
    var sequence_table = [];
    var countValid = 0;
    var counterRelay = 0;
    var firstSeq = "";
    var secondSeq = "";
    var lines = fastaFile.split('\n');
    for (var j = 0; j < lines.length; j++) {
        var line = lines[j];
        line = line.trim();
        if (line.length !== 0) {
            if (line[0] === '>') {
                countValid++;
                continue;
            }
            if (countValid === 1) {
                firstSeq += line;
            }
            if (countValid > 1) {
                secondSeq += line;
            }
        }
    }
    if (firstSeq[firstSeq.length - 1] !== "K") {
        firstSeq = firstSeq + "#K";
    }
    if (secondSeq[secondSeq.length - 1] !== "K") {
        secondSeq = secondSeq + "#K";
    }
    var splitseq1 = firstSeq.match(/([^KR])*[KR]?/g);
    splitseq1.pop();
    for (var i = 0; i < splitseq1.length; i++) {
        if (i === splitseq1.length - 1) {
            var lastElement = splitseq1[i];
            if (lastElement[lastElement.length - 2] === "#") {
                splitseq1[i] = splitseq1[i].substring(0, lastElement.length - 2);
            }
        }
        sequence_table.push({id: counterRelay, uniqueNumber: i, sequence: splitseq1[i].toString().toUpperCase(), countNumber: splitseq1[i].length, type: 1});
        counterRelay++;
    }
    var splitseq2 = secondSeq.match(/([^KR])*[KR]?/g);
    splitseq2.pop();
    for (var j = 0; j < splitseq2.length; j++) {
        if (j === splitseq2.length - 1) {
            var lastElement = splitseq2[j];
            if (lastElement[lastElement.length - 2] === "#") {
                splitseq2[j] = splitseq2[j].substring(0, lastElement.length - 2);
            }
        }
        sequence_table.push({id: counterRelay, uniqueNumber: j, sequence: splitseq2[j].toString().toUpperCase(), countNumber: splitseq2[j].length, type: 2});
        counterRelay++;
    }
    return sequence_table;
}

function createBlockTable(dataFile) {
    var blocks = [];
    var precursorinfo = [];
    var lines = dataFile.split("\n");
    var reactionCounter = 0;
    for (var j = 2; j < lines.length; j++) {
        var line = lines[j];
        if (line.length > 0) {
            if (isNaN(line[0])) {
                var splitseq = line.split("\t");
                var frag1Filtered = checkForSpecialCharacters(splitseq[2].toString().toUpperCase());
                var frag2Filtered = checkForSpecialCharacters(splitseq[3].toString().toUpperCase());
                reactionCounter++;
                blocks.push({id: reactionCounter, title: splitseq[0], mz: splitseq[1], fragment1: frag1Filtered.toString(), fragment2: frag2Filtered.toString(), tmass: splitseq[4], amass: splitseq[5], charge: splitseq[6], score: splitseq[7]});

            }
            else {
                var info = reactionCounter + line;
                var splitinfo = info.split("\t");
                precursorinfo.push({blockId: splitinfo[0], frag1: splitinfo[2], frag2: splitinfo[3], score: splitinfo[4]});
            }
        }
    }
    return {blocks: blocks, precursorinfo: precursorinfo};
}

function createPointsTable(sequences, blocks) {
    var points = [];
    var filteredPoints = [];
    var pointsID = 0;
    function getUniqueNumberForSequence(fragment, sequence, type) {
        var uniqueNumber;
        var seqObject = sequences({sequence: sequence, type: type}).get();
        if (seqObject.length === 0) {
            alert("Data file does not match FASTA file!");
            clearSVG();
            return;
        }
        if (seqObject.length === 1) {
            uniqueNumber = seqObject[0].uniqueNumber;
        }
        if (seqObject.length > 1) {
            seqObject.forEach(function (seqObj, j) {
                var dividedFrag = fragment.toString().toUpperCase().match(/([^KR])*[KR]?/g);
                dividedFrag.pop();
                dividedFrag.forEach(function (seq, i) {
                    if (sequence === seq) {
                        var dividedFragObj = sequences({sequence: dividedFrag[0], type: type}).get();
                        uniqueNumber = dividedFragObj[0].uniqueNumber + i;
                    }
                });
            });
        }
        return uniqueNumber;
    }
    var result = blocks().get();
    result.forEach(function (r) {
        var seqs1 = r.fragment1;
        var splitseq1 = seqs1.match(/([^KR])*[KR]?/g);
        splitseq1.pop();
        var seqs2 = r.fragment2;
        var splitseq2 = seqs2.match(/([^KR])*[KR]?/g);
        splitseq2.pop();
        splitseq1.forEach(function (s1) {
            splitseq2.forEach(function (s2) {
                var sourceNumber = getUniqueNumberForSequence(seqs1.toString().toUpperCase(), s1, 1);
                var targetNumber = getUniqueNumberForSequence(seqs2.toString().toUpperCase(), s2, 2);
                points.push({id: pointsID, blockId: r.id, sequence1: s1, sequence2: s2, score: r.score, sourceNumber: sourceNumber, targetNumber: targetNumber, title: r.title, mz: r.mz, tmass: r.tmass,
                    amass: r.amass, charge: r.charge});
                pointsID++;
            });
        });
    });
    var points_table = TAFFY(points);
    var query2 = points_table().distinct("sequence1", "sequence2");
    query2.forEach(function (element) {
        var elements = points_table({sequence1: element[0], sequence2: element[1]}).get();
        var elements_table = TAFFY(elements);
        var maxScore = elements_table().max("score");
        var pointObj = points_table({sequence1: element[0], sequence2: element[1], score: maxScore}).get();
        var sourceNumber = pointObj[0].sourceNumber;
        var targetNumber = pointObj[0].targetNumber;
        filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(maxScore),
            id: pointObj[0].id, sequence1: pointObj[0].sequence1, sequence2: pointObj[0].sequence2,
            title: pointObj[0].title, mz: pointObj[0].mz, tmass: pointObj[0].tmass,
            amass: pointObj[0].amass, charge: pointObj[0].charge});
    });
    var filteredPointsTable = TAFFY(filteredPoints);
    return {filteredPointsTable: filteredPointsTable, points_table: points_table};
}

function createSlider() {
    var height = unit;
    var width = document.getElementById("vis").offsetWidth - (7 * unit);
    var x = d3.scale.linear().domain([0.1, 1.5]).range([0, width]).clamp(true);
    var brush = d3.svg.brush().x(x).extent([0, 0]).on("brush", brushed);
    var svg = d3.select("#scaleGroup");
    svg.attr("transform", "translate(" + 2 * unit + "," + 1.5 * unit + ")");
    svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height / 2 + ")").call(d3.svg.axis().scale(x).orient("bottom").tickSize(1).tickPadding(10).tickValues([0, 100]));
    var slider = svg.append("g").attr("class", "slider").call(brush);
    slider.selectAll(".extent,.resize").remove();
    slider.select(".background").attr("height", height);
    var handle = slider.append("circle").attr("class", "handle").attr("transform", "translate(0," + height / 2 + ")").attr("r", 5);
    slider.call(brush.event).transition().duration(750).call(brush.extent([100, 100])).call(brush.event);
    function brushed() {

        if (fileWeight >= 20000) {
            scaleValue = 0.5;
            if (fileWeight >= 300000) {
                scaleValue = 0.1;
            }
        }
        if (fileWeight < 20000) {
            scaleValue = 0.5;
            if (fileWeight < 10000) {
                scaleValue = 1;
            }
        }
        var value = scaleValue;
        if (d3.event.sourceEvent) {
            value = x.invert(d3.mouse(this)[0]);
            brush.extent([value, value]);
        }
        handle.attr("cx", x(value));
        d3.select("#first").attr("transform", "scale(" + value + ")");
    }
}

//Create first level visualization of the whole spectra data file
function displaySequenceTable(sequence_table, width, height) {
    var rowCount = 0;
    var columnCount = 0;
    var seqOneCount = 0;
    var rowHeaders = [];
    var columnHeaders = [];
    var yCount = 0;
    var xCount = 0;
    var lengthValue = -3;
    var lengthValueText = -3;
    var temp = [];
    var tempText = [];
    temp[0] = 3;
    tempText[0] = 3;
    var cellHeigts = [];
    var computedLengthsArray = [];
    var widthValue = -3;
    var widthValueText = -3;
    var anotherTempText = [];
    anotherTempText[0] = 3;
    var anotherTemp = [];
    anotherTemp[0] = 3;
    var cellWidths = [];
    var computedLengthsArrayColumn = [];
    sequence_table.forEach(function (node) {
        if (node.type === 1) {
            columnCount = columnCount + node.sequence.length;
            columnHeaders[xCount] = node.sequence;
            seqOneCount++;
            xCount++;
        }
        if (node.type === 2) {
            rowCount = rowCount + node.sequence.length;
            rowHeaders[yCount] = node.sequence;
            yCount++;
        }
    });
    var rect = d3.select("#first").append("rect")
            .attr("class", "background")
            .attr("width", width)
            .attr("height", height).attr("fill", "#A9A9A9");
    var row = d3.select("#first").selectAll(".row")
            .data(rowHeaders)
            .enter().append("g")
            .attr("class", "row");
    row.append("text")
            .attr("x", 0)
            .attr("y", 8.272)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d, i) {
                return d;
            }).attr("transform", function (d, i) {
        computedLengthsArray[i] = this.getComputedTextLength();
        lengthValueText = lengthValueText + tempText[i];
        tempText[i + 1] = computedLengthsArray[i];
        var h = lengthValueText;
        return "translate(0," + h + ")rotate(90)";
    });
    var column = d3.select("#first").selectAll(".column")
            .data(columnHeaders)
            .enter().append("g")
            .attr("class", "column");
    column.append("text")
            .attr("x", 0)
            .attr("y", 12.4)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d) {
                return d;
            }).attr("transform", function (d, i) {
        computedLengthsArrayColumn[i] = this.getComputedTextLength();
        widthValueText = widthValueText + anotherTempText[i];
        anotherTempText[i + 1] = computedLengthsArrayColumn[i];
        var w = widthValueText;
        return "translate(" + w + ",-20)";
    });
    var newWidth;
    var totalWidth = 0;
    computedLengthsArrayColumn.forEach(function (w) {
        totalWidth += w;
    });
    newWidth = totalWidth;
    var newHeight;
    var totalHeight = 0;
    computedLengthsArray.forEach(function (l) {
        totalHeight += l;
    });
    newHeight = totalHeight;
    row.append("line").attr("stroke", "#fff")
            .attr("x2", newWidth).attr("transform", function (d, i) {
        lengthValue = lengthValue + temp[i];
        temp[i + 1] = computedLengthsArray[i];
        var h = lengthValue;
        cellHeigts.push(h);
        return "translate(0," + h + ")";
    });
    column.append("line").attr("stroke", "#fff")
            .attr("x1", -newHeight).attr("transform", function (d, i) {
        widthValue = widthValue + anotherTemp[i];
        anotherTemp[i + 1] = computedLengthsArrayColumn[i];
        var w = widthValue;
        cellWidths.push(w);
        return "translate(" + w + ")rotate(-90)";
    });
    rect.attr("width", newWidth).attr("height", newHeight);
    var cellHeightLastElement = cellHeigts[cellHeigts.length - 1] + computedLengthsArray[computedLengthsArray.length - 1];
    var cellWidthsLastElement = cellWidths[cellWidths.length - 1] + computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
    cellHeigts.push(cellHeightLastElement);
    cellWidths.push(cellWidthsLastElement);
    return {
        cellHeigts: cellHeigts,
        cellWidths: cellWidths,
        rectHeight: newHeight,
        rectWidth: newWidth
    };
}

function createDataPointsOnMatrix(cellHeigts, cellWidths, pointsTaffyObject, points_table, blocks, precursorinfo, color, newHeight, newWidth) {
    var matrix = [];
    var rowCellHeigtsTemp = [];
    rowCellHeigtsTemp[0] = 0;
    var rowCellHeigts = [];
    rowCellHeigts[0] = 0;
    var rowColumnWidthsTemp = [];
    rowColumnWidthsTemp[0] = 0;
    var rowColumnWidths = [];
    rowColumnWidths[0] = 0;
    for (var i = 0; i < cellHeigts.length; i++) {
        matrix[i] = d3.range(cellWidths.length).map(function (j) {
            return {w: 0, h: 0, positionX: 0, positionY: 0, title: '', mz: 0, tmass: 0,
                amass: 0, charge: 0, sequence1: '', sequence2: '', source: 0, target: 0, value: 0};
        });
    }
    var points = pointsTaffyObject().get();
    points.forEach(function (point) {
        matrix[point.target][point.source].title = point.title;
        matrix[point.target][point.source].mz = point.mz;
        matrix[point.target][point.source].tmass = point.tmass;
        matrix[point.target][point.source].amass = point.amass;
        matrix[point.target][point.source].charge = point.charge;
        matrix[point.target][point.source].sequence1 = point.sequence1;
        matrix[point.target][point.source].sequence2 = point.sequence2;
        matrix[point.target][point.source].source = point.target;
        matrix[point.target][point.source].target = point.source;
        matrix[point.target][point.source].value = point.value;
    });
    cellHeigts.forEach(function (height, i) {
        var temp = rowCellHeigtsTemp[i] - height;
        i += 1;
        rowCellHeigtsTemp[i] = height;
        rowCellHeigts[i] = Math.abs(temp);
    });
    cellWidths.forEach(function (width, i) {
        var temp = rowColumnWidthsTemp[i] - width;
        i += 1;
        rowColumnWidthsTemp[i] = width;
        rowColumnWidths[i] = Math.abs(temp);
    });

    rowCellHeigts.shift();
    rowCellHeigts.shift();
    rowColumnWidths.shift();
    rowColumnWidths.shift();
    rowCellHeigtsTemp.shift();
    rowColumnWidthsTemp.shift();
    var existingData = [];
    matrix.forEach(function (d, i) {
        d.forEach(function (cell, j) {
            if (cell.value !== 0) {
                cell.w = rowColumnWidths[j];
                cell.h = rowCellHeigts[i];
                cell.positionX = rowColumnWidthsTemp[j];
                cell.positionY = rowCellHeigtsTemp[i];
                existingData.push(cell);
            }
        });
    });

    var fillOpacities = [];
    var colorSelected = {color: '', opacity: 0};
    var blockArraySorted = existingData.sort(function (a, b) {
        return a.value - b.value;
    });
    var minScore = blockArraySorted[0].value;
    var maxScore = blockArraySorted[blockArraySorted.length - 1].value;
    var z = d3.scale.linear().domain([minScore, maxScore]).range([0.1, 1]);
    existingData.forEach(function (d, i) {
        var fillOpacitiesTaffy;
        d3.select("#first").append("rect")
                .attr("x", d.positionX)
                .attr("y", d.positionY)
                .attr("width", d.w - 1)
                .attr("height", d.h - 1).style("fill", color).style("fill-opacity", function () {
            var opacityValue = z(d.value);
            colorSelected.opacity = opacityValue;
            fillOpacities.push({opacityValue: opacityValue, value: d.value});
            fillOpacitiesTaffy = TAFFY(fillOpacities);
            return opacityValue;
        })
                .on("click", function () {
                    if (d3.event.defaultPrevented)
                        return;
                    colorSelected.color = color;
                    var opacityObject = fillOpacitiesTaffy({value: d.value}).get();
                    colorSelected.opacity = opacityObject[0].opacityValue;
                    d3.select("#third").remove();
                    d3.select("#second").remove();
                    visGroup.append("g").attr("id", "second");
                    minimize("#first", 0, 0, scaleValue);
                    createTreemap(points_table, d.sequence1, d.sequence2, blocks, precursorinfo, colorSelected);
                    //scaleContentForDevice(d3.select("second"));
                })
                .append("title")
                .text("Sequence 1: " + d.sequence1 + "\nSequence 2: " + d.sequence2 + "\nScore: " + d.value);
    });

    function compare(a, b) {
        if (a.value < b.value)
            return -1;
        if (a.value > b.value)
            return 1;
        return 0;
    }
    fillOpacities.sort(compare);
    var flags = [], fillOpacitiesDistinctArray = [], l = fillOpacities.length, i;
    for (i = 0; i < l; i++) {
        if (flags[fillOpacities[i].value])
            continue;
        flags[fillOpacities[i].value] = true;
        fillOpacitiesDistinctArray.push(fillOpacities[i]);
    }
    makeLegend(fillOpacitiesDistinctArray, "#000099", 2 * unit, unit / 1.5, document.getElementById("vis").offsetWidth - (7 * unit), unit, "horizontal", "legendGroup", unit, "15px");
    treemapX = (2 * unit) + (document.getElementById("vis").offsetWidth - (7 * unit));
    colorLegendHeight = unit;
    return existingData;
}

//Create the second level (Occurences of every combination of sequences)
function createTreemap(points, sequence1, sequence2, blocks, precursorinfo, colorSelected) {
    var results = points({sequence1: sequence1, sequence2: sequence2}).get();
    var root = {name: sequence1 + " " + sequence2, children: []};
    results.forEach(function (result) {
        root.children.push({name: "possibility", blockId: result.blockId, size: result.score, amass: result.amass, charge: result.charge, mz: result.mz, sequence1: result.sequence1, sequence2: result.sequence2, title: result.title, tmass: result.tmass});
    });
    var width = 40 * unit;
    var height = 24 * unit;
    var x = d3.scale.linear().domain([0.3, 1.35]).range([1, 100]).clamp(true);
    var treemap = d3.layout.treemap().size([width, height]).round(true).sticky(true).sort(function (a, b) {
        return a.size - b.size;
    }).value(function (d) {
        return x(d.size);
    });
    treemapWidth = width;
    treemapHeigt = height;
    treemapY = height + colorLegendHeight + unit;
    var transformYValue = 0;
    var transformXValue = treemapX - width;
    var treeMapGroup = d3.select("#second").attr("transform", "translate(" + transformXValue + "," + transformYValue + ")");
    treeMapGroup.append("g").append("text").text(function (d) {
        return sequence1 + "      " + sequence2;
    }).attr("transform", function () {
        var textPositionX = (width / 2) - this.getComputedTextLength();
        return "translate(" + textPositionX + ",-10)";
    }).attr("font-size", "20px");
    var cell = treeMapGroup.datum(root).selectAll(".leaf").data(treemap.nodes(root))
            .enter().append("g")
            .attr("class", "leaf")
            .attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
    cell.append("rect")
            .attr("width", function (d) {
                return d.dx;
            })
            .attr("height", function (d) {
                return d.dy;
            })
            .style("fill", function () {
                return colorSelected.color;
            })
            .style("fill-opacity", function () {
                return colorSelected.opacity;
            })
            .style("stroke", "#FFF")
            .style("stroke-width", "2");

    cell.append("foreignObject")
            .attr("x", 5).attr("y", 5)
            .attr("dx", "1.8em")
            .attr("dy", "1.0em")
            .attr("text-anchor", "middle")
            .attr("font-size", "10px").attr("color", function (d) {
        if (d.size >= 0.08) {
            return "#fff";
        }
        else if (d.size < 0.08) {
            return "#000";
        }
    }).attr("width", function (d) {
        return d.dx;
    }).attr("height", function (d) {
        return d.dy;
    }).append("xhtml:body")
            .html(function (d) {
                var blockData = blocks({id: d.blockId}).get();
                var textString = "";
                if (blockData.length !== 0) {
                    textString = "<div>" + blockData[0].fragment1 + "</div>" + "<br/><div>" + blockData[0].fragment2 + "</div>" + "<br/><div>" + blockData[0].score + "</div>";
                    return textString;
                }
            }).style("overflow", "hidden");

    cell.append("title")
            .text(function (d) {
                return  "Title: " + d.title + "\n M/Z: " + d.mz + "\n Charge: " + d.charge + "\n T-Mass: " + d.tmass + "\n E-Mass: " + d.amass;
            });

    cell.on("click", function (d) {
        d3.select("#third").remove();
        visGroup.append("g").attr("id", "third");
        createFinalLevel(blocks, d.blockId, precursorinfo);
        //scaleContentForDevice(d3.select("third"));
                     
        var blockData = blocks({id: d.blockId}).get();
         //console.log(blockData);
        var splitseq1 = [];
        var splitseq2 = [];
        var splitseq1Obj;
        var splitseq2Obj;
        var peptideArray1 = [];
        var peptideArray2 = [];
        if(blockData.length != 0){
             splitseq1 = blockData[0].fragment1.match(/([^KR])*[KR]?/g);
             splitseq1.pop();
             splitseq2 = blockData[0].fragment2.match(/([^KR])*[KR]?/g);
             splitseq2.pop();
        }

    for (var i = 0; i < splitseq1.length; i++) {
        //console.log(i);
        if (i === splitseq1.length - 1) {
            var lastElement = splitseq1[i];
            if (lastElement[lastElement.length - 2] === "#") {
                splitseq1[i] = splitseq1[i].substring(0, lastElement.length - 2);
            }
        }
        console.log(splitseq1[i].toString());
        var sequenceSearchResult = sequences_table_taffy({sequence: splitseq1[i].toString(), type: 1}).get();
       //console.log(sequenceSearchResult);
       for(var j =0 ; j<sequenceSearchResult[0].countNumber;j++){
           var itemToBePushed = sequenceSearchResult[0].id + j + sequenceSearchResult[0].countNumber + 1;
            console.log(itemToBePushed);
           //console.log(itemToBePushed);
           peptideArray1.push(itemToBePushed);
       }
       
    }
    for (var i = 0; i < splitseq2.length; i++) {
                if (i === splitseq2.length - 1) {
            var lastElement = splitseq2[i];
            if (lastElement[lastElement.length - 2] === "#") {
                splitseq2[i] = splitseq2[i].substring(0, lastElement.length - 2);
            }
        }
        var sequenceSearchResult = sequences_table_taffy({sequence: splitseq2[i].toString(), type: 2}).get();
       //console.log(sequenceSearchResult);
       for(var j =0 ; j<sequenceSearchResult[0].countNumber;j++){
           var itemToBePushed = sequenceSearchResult[0].id + j + sequenceSearchResult[0].countNumber + 1;
           console.log(itemToBePushed);
           //console.log(itemToBePushed);
           peptideArray2.push(itemToBePushed);
       }
    }
    peptide_1_selected = peptideArray1;
    peptide_2_selected = peptideArray2;
       
        //$("#glmol01").html("");
        console.log("---------------");
        console.log($("#firstseq").val());
        console.log($("#secondseq").val());
        console.log(peptideArray1);
        console.log(peptideArray2);
        var previousArray1 = [0];
        var previousArray2 = [0];
        view($("#firstseq").val(), $("#secondseq").val(), peptideArray1, peptideArray2, previousArray1, previousArray2, "0xA9A9A9", "0xA9A9A9", "0x0000ff");
        //updateView();
    });
}

// Display Final Level (Precursor information level)
function createFinalLevel(blocks, blockid, precursorinfo) {
    var blockdata = blocks({id: blockid}).get();
    var precursorinfodata = precursorinfo({blockId: blockid + ""}).get();
    var counterRelay = 0;
    var character_table = [];
    var frag1 = blockdata[0].fragment1;
    var frag2 = blockdata[0].fragment2;
    var splitseq1 = frag1.match(/./g);
    for (var i = 0; i < splitseq1.length; i++) {
        character_table.push({id: counterRelay, uniqueNumber: i, sequence: splitseq1[i].toString().toUpperCase(), type: 1});
        counterRelay++;
    }
    var splitseq2 = frag2.match(/./g);
    for (var j = 0; j < splitseq2.length; j++) {
        character_table.push({id: counterRelay, uniqueNumber: j, sequence: splitseq2[j].toString().toUpperCase(), type: 2});
        counterRelay++;
    }
    var transformYValue = treemapY + (2 * unit);
    var resultArray = displayCharacterTable(character_table);
    var transformXValue = treemapX - treemapWidth - (thirdLevelWidth * 2) - 5;
    thirdLevelX = transformXValue;
    thirdLevelY = transformYValue;
    d3.select("#third").attr("transform", "translate(" + transformXValue + "," + 0 + ")scale(2)");
    var filteredPoints = [];
    precursorinfodata.forEach(function (info) {
        var sourceNumber = info.frag1 - 1;
        var targetNumber = info.frag2 - 1;
        filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(info.score)});
    });
    var charTableObj = TAFFY(character_table);
    character_table_taffy = charTableObj;
    var filteredPointsTaffyObject = TAFFY(filteredPoints);
    createDataPointsOnMatrixForCharacterTable(resultArray.cellHeigts, resultArray.cellWidths, filteredPointsTaffyObject, charTableObj);
}

function displayCharacterTable(character_table) {
    var rowCount = 0;
    var columnCount = 0;
    var seqOneCount = 0;
    var rowHeaders = [];
    var columnHeaders = [];
    var yCount = 0;
    var xCount = 0;
    var lengthValue = -3;
    var lengthValueText = -3;
    var temp = [];
    var tempText = [];
    temp[0] = 3;
    tempText[0] = 3;
    var cellHeigts = [];
    var computedLengthsArray = [];
    var widthValue = -3;
    var widthValueText = -3;
    var anotherTempText = [];
    anotherTempText[0] = 3;
    var anotherTemp = [];
    anotherTemp[0] = 3;
    var cellWidths = [];
    var computedLengthsArrayColumn = [];
    character_table.forEach(function (node) {
        if (node.type === 1) {
            columnCount = columnCount + node.sequence.length;
            columnHeaders[xCount] = node.sequence;
            seqOneCount++;
            xCount++;
        }
        if (node.type === 2) {
            rowCount = rowCount + node.sequence.length;
            rowHeaders[yCount] = node.sequence;
            yCount++;
        }
    });
    var moveY = document.getElementById("first").getBBox().width;
    var rect = d3.select("#third").append("rect")
            .attr("class", "backgroundThrd")
            .attr("width", document.getElementById("second").getBBox().width)
            .attr("height", document.getElementById("second").getBBox().height).attr("fill", "#A9A9A9").on("click", function (d) {
    });
    var row = d3.select("#third").selectAll(".row")
            .data(rowHeaders)
            .enter().append("g")
            .attr("class", "row");
    var rowText = row.append("text")
            .attr("x", function (d) {
                if (d === "I") {
                    return 2.5;
                }
                else {
                    return 0;
                }
            })
            .attr("y", 8)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d, i) {
                return d;
            }).attr("overflow", function (d, i) {
        computedLengthsArray[i] = this.getComputedTextLength();
    });
    var column = d3.select("#third").selectAll(".column")
            .data(columnHeaders)
            .enter().append("g")
            .attr("class", "column");
    var columnText = column.append("text")
            .attr("x", function (d) {
                if (d === "I") {
                    return 2.5;
                }
                else {
                    return 0;
                }
            })
            .attr("y", 12)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d) {
                return d;
            }).attr("overflow", function (d, i) {
        computedLengthsArrayColumn[i] = this.getComputedTextLength();
    });
    computedLengthsArray.sort();
    computedLengthsArrayColumn.sort();
    rowText.attr("transform", function (d, i) {
        lengthValueText = lengthValueText + tempText[i];
        tempText[i + 1] = computedLengthsArray[computedLengthsArray.length - 1];
        var h = lengthValueText;
        return "translate(0," + h + ")rotate(90)";
    });
    columnText.attr("transform", function (d, i) {
        widthValueText = widthValueText + anotherTempText[i];
        anotherTempText[i + 1] = computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
        var w = widthValueText;
        return "translate(" + w + ",-20)";
    });
    var newHeight;
    var totalHeight = 0;
    computedLengthsArray.forEach(function (l) {
        totalHeight += computedLengthsArray[computedLengthsArray.length - 1];
    });
    newHeight = totalHeight;
    var newWidth;
    var totalWidth = 0;
    computedLengthsArrayColumn.forEach(function (w) {
        totalWidth += computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
    });
    newWidth = totalWidth;
    row.append("line").attr("stroke", "#fff")
            .attr("x2", newWidth).attr("transform", function (d, i) {
        lengthValue = lengthValue + temp[i];
        temp[i + 1] = computedLengthsArray[computedLengthsArray.length - 1];
        var h = lengthValue;
        cellHeigts.push(h);
        return "translate(0," + h + ")";
    });
    column.append("line").attr("stroke", "#fff")
            .attr("x1", -newHeight).attr("transform", function (d, i) {
        widthValue = widthValue + anotherTemp[i];
        anotherTemp[i + 1] = computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
        var w = widthValue;
        cellWidths.push(w);
        return "translate(" + w + ")rotate(-90)";
    });
    rect.attr("width", newWidth).attr("height", newHeight);
    thirdLevelWidth = newWidth;
    thirdLevelHeight = newHeight;
    return {
        cellHeigts: cellHeigts,
        cellWidths: cellWidths,
        rectHeight: newHeight,
        rectWidth: newWidth
    };
}

function createDataPointsOnMatrixForCharacterTable(cellHeigts, cellWidths, pointsTaffyObject, points_table) {
    var matrix = [];
    var rowCellHeigtsTemp = [];
    rowCellHeigtsTemp[0] = 0;
    var rowCellHeigts = [];
    rowCellHeigts[0] = 0;
    var rowColumnWidthsTemp = [];
    rowColumnWidthsTemp[0] = 0;
    var rowColumnWidths = [];
    rowColumnWidths[0] = 0;
    for (var i = 0; i < cellHeigts.length; i++) {
        matrix[i] = d3.range(cellWidths.length).map(function (j) {
            return {w: 0, h: 0, positionX: 0, positionY: 0, char1: '', char2: '', source: j, target: i, score: 0};
        });
    }
    var points = pointsTaffyObject().get();
    if (points.length != 0) {
        points.forEach(function (point) {
            matrix[point.target][point.source].score = point.value;
            matrix[point.target][point.source].char1 = points_table({uniqueNumber: point.source, type: 1}).get()[0].sequence;
            matrix[point.target][point.source].char2 = points_table({uniqueNumber: point.target, type: 2}).get()[0].sequence;
        });
    } else {
        matrix[0][0].score = 0;
        matrix[0][0].char1 = '';
        matrix[0][0].char2 = '';
    }
    cellHeigts.forEach(function (height, i) {
        var temp = rowCellHeigtsTemp[i] - height;
        i += 1;
        rowCellHeigtsTemp[i] = height;
        rowCellHeigts[i] = Math.abs(temp);
    });
    cellWidths.forEach(function (width, i) {
        var temp = rowColumnWidthsTemp[i] - width;
        i += 1;
        rowColumnWidthsTemp[i] = width;
        rowColumnWidths[i] = Math.abs(temp);
    });
    rowCellHeigts.shift();
    rowCellHeigts.shift();
    rowColumnWidths.shift();
    rowColumnWidths.shift();
    rowCellHeigtsTemp.shift();
    rowColumnWidthsTemp.shift();
    var existingData = [];
    matrix.forEach(function (d, i) {
        d.forEach(function (cell, j) {
            if (cell.score !== 0) {
                cell.w = rowColumnWidths[j];
                cell.h = rowCellHeigts[i];
                cell.positionX = rowColumnWidthsTemp[j];
                cell.positionY = rowCellHeigtsTemp[i];
                existingData.push(cell);
            }
        });
    });
    var fillOpacities = [];
    var colorSelected = {color: '', opacity: 0};
    var blockArraySorted = [];
    var minScore;
    var maxScore;
    if (existingData.length > 1) {
        blockArraySorted = existingData.sort(function (a, b) {
            return a.score - b.score;
        });
        minScore = blockArraySorted[0].score;
        maxScore = blockArraySorted[blockArraySorted.length - 1].score;
    }
    if (existingData.length === 1) {
        minScore = 0;
        maxScore = existingData[0].score;
    }
    if (existingData.length === 0) {
        minScore = 0;
        maxScore = 0;
    }
    var z = d3.scale.linear().domain([minScore, maxScore]).range([0.5, 2]).clamp(true);
    existingData.forEach(function (d, i) {
      d3.select("#third").append("rect")
                .attr("x", d.positionX)
                .attr("y", d.positionY)
                .attr("width", d.w - 1)
                .attr("height", d.h - 1).style("fill", "brown").style("fill-opacity", function () {
            var opacityValue = z(d.score);
            colorSelected.opacity = opacityValue;
            fillOpacities.push({opacityValue: opacityValue, value: d.score});
            return opacityValue;
        }).on("click", function () {
            //console.log("final clicked");
             //console.log(d);
        //$("#structure").show();
        $("#glmol01").html("");
        var peptideArray1 = [];
        var peptideArray2 = [];
        peptideArray1.push(peptide_1_selected[d.source]);
        peptideArray2.push(peptide_2_selected[d.target]);
        console.log("-----------");
        console.log(peptideArray1);
        console.log(peptideArray2);
        console.log(peptide_1_selected);
        console.log(peptide_2_selected);
        console.log(peptide_1_selected[d.source]);
        console.log(peptide_2_selected[d.target]);
        console.log("-----------");
        view($("#firstseq").val(), $("#secondseq").val(), peptideArray1, peptideArray2, peptide_1_selected, peptide_2_selected, "0xA9A9A9", "0x0000ff", "0xff0000");
        }).append("title")
                .text("Sequence 1: " + d.char1 + "\nSequence 2: " + d.char2 + "\nScore: " + d.score);
        peptide_1_selected = [];
        peptide_2_selected = [];
    });
    function compare(a, b) {
        if (a.value < b.value)
            return -1;
        if (a.value > b.value)
            return 1;
        return 0;
    }
    fillOpacities.sort(compare);
    makeLegend(fillOpacities, "brown", 0, thirdLevelHeight + 5, thirdLevelWidth - 15, 10, "horizontal", "third", unit, "5px");
    return existingData;
}

function main(fastaFile, dataFile) {
    $("#vis").show();
    $("#structure").show();
    if (localFlag == true) {
        constructStructuresPDB();
    }
    else {
        constructStructures();
    }
    var dim = calculateLWSVG(fastaFile);
    var sequence_table = createSequenceTable(fastaFile);
    var sequences = TAFFY(sequence_table);
    sequences_table_taffy = sequences;
    var block_table = createBlockTable(dataFile);
    var blocks = TAFFY(block_table.blocks);
    var precursorinfo = TAFFY(block_table.precursorinfo);
    var initObj = init(dim);
    var resultArray = displaySequenceTable(sequence_table, initObj.width, initObj.height);
    var points = createPointsTable(sequences, blocks);
    createDataPointsOnMatrix(resultArray.cellHeigts, resultArray.cellWidths, points.filteredPointsTable, points.points_table, blocks, precursorinfo, "#000099", resultArray.rectHeight, resultArray.rectWidth);
    createSlider();
    //scaleContentForDevice(d3.select("first"));
    d3.select("#mainButton").attr("disabled", "true");
    svgDrawnFlag = 1;
}